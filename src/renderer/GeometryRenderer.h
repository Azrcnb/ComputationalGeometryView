#pragma once

#include <glad/glad.h>
#include <glm/glm.hpp>
#include <vector>
#include <memory>

// Include geometry headers for types (Vector3, Point3D)
#include "geometry/curves/CubicSpline.h" 
#include "geometry/surfaces/CubicBezierPatch.h"
#include "shader_m.h"

/**
 * @brief Represents a single vertex in the rendering pipeline.
 */
struct Vertex {
    glm::vec3 position;
    glm::vec3 color;
    glm::vec3 normal;

    Vertex(glm::vec3 pos, glm::vec3 col = glm::vec3(1.0f), glm::vec3 norm = glm::vec3(0.0f, 0.0f, 1.0f))
        : position(pos), color(col), normal(norm) {
    }
};

enum class GeometryType {
    CURVE,
    SURFACE,
    AXES,
    GRID
};

struct GeometryData {
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    GeometryType type;

    GeometryData(GeometryType t) : type(t) {}
};

/**
 * @brief Handles OpenGL rendering of geometric objects.
 */
class GeometryRenderer {
public:
    GeometryRenderer();
    ~GeometryRenderer();

    void init();
    void clear();
    void addGeometry(const GeometryData& geometry);
    void addAxes(float length = 10.0f);
    void render(const glm::mat4& projection, const glm::mat4& view, const glm::mat4& model, const glm::vec3& cameraPos);

    /**
     * @brief Converts a list of discrete 3D points into renderable curve geometry.
     *
     * @param curvePoints The list of points generated by the spline (Model).
     * @param color The color of the curve.
     * @param outData Output GeometryData.
     */
    void convertCurveToGeometry(const std::vector<Vector3>& curvePoints, const glm::vec3& color, GeometryData& outData);

    /**
     * @brief Converts a list of disjoint line segments into grid geometry (Lines).
     * Expected input: Pairs of points (P0, P1, P2, P3...) defining segments P0-P1, P2-P3...
     */
    void convertGridToGeometry(const std::vector<Vector3>& gridPoints, const glm::vec3& color, GeometryData& outData);

    /**
     * @brief Converts a mesh (vertices + indices) into renderable surface geometry.
     * Automatically calculates smooth normals.
     *
     * @param meshVertices The list of vertices generated by the surface patch.
     * @param meshIndices The list of indices defining the triangles.
     * @param color The base color of the surface.
     * @param outData Output GeometryData.
     */
    void convertSurfaceToGeometry(const std::vector<Vector3>& meshVertices, const std::vector<unsigned int>& meshIndices, const glm::vec3& color, GeometryData& outData);

private:
    /**
     * @brief Helper function to calculate smooth normals for a triangular mesh.
     *
     * @param vertices List of vertices to be updated with normal data.
     * @param indices List of indices defining the mesh topology.
     */
    void calculateSmoothNormals(std::vector<Vertex>& vertices, const std::vector<unsigned int>& indices);

    std::vector<GLuint> vaoHandles;
    std::vector<GLuint> vboHandles;
    std::vector<GLuint> eboHandles;
    std::vector<GeometryData> geometries;
    std::unique_ptr<Shader> shaderProgram;
};
